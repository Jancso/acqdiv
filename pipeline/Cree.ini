[corpus]
iso639-3 == cre
glottolog_code == cree1272
format == ChatXML
language == Cree
corpus == Cree
owner == Julie Brittain

[paths]
sessions == ../corpora/Cree/xml/*.xml
sessions_dir == ../corpora/Cree/xml/
metadata_dir == ../corpora/Cree/xml/
parser == CreeParser
parser_name == CreeParser

[metadata]
# TODO: parse from the XML eventually
# type == XML
type == JSON
cdc == yes
cdc_path == corpora/Cree/cha/0metadata.cdc

[tests]
sessions == ../corpora/test_corpora/Cree/xml/*.xml
sessions_dir == ../corpora/test_corpora/Cree/xml/
metadata_dir == ../corpora/test_corpora/Cree/xml/
#sessions == tests/corpora/Cree/xml/Cree.xml
#sessions_dir == tests/corpora/Cree/
#metadata_dir == tests/corpora/Cree/xml/
format == ChatXML

[speaker_labels]
id == speaker_label
name == name
age == age_raw
role == role_raw
sex == gender_raw
birthday == birthdate

[session_labels]
Date == date
Id == source_id
Media == media
Mediatypes == media_type

[json_mappings_utterance]
utterance_id == utterance_id
speaker_id == speaker_label
starts_at == start_raw
ends_at == end_raw
english == translation
comments == comment
sentence_type == sentence_type
warnings == warning

[json_mappings_words]
full_word == word_actual
full_word_target == word_target
warnings == warning
# assign the proper actual vs target "word" given the corpus
word == word_actual

[morphemes]
# Cree makes a distinction actual and target segment; see acqdiv manual
type == target

[json_mappings_morphemes]
segments_target == morpheme
glosses_target == gloss_raw
pos_target == pos_raw

[gloss]
0 == 0
0.s == 0
1 == 1
1/2 == 1/2
1>2 == 1>2
1>3 == 1>3
1pl == 1PL
1s == 1SG
2 == 2
2.pl.IMP == IMP.2PL.EXCL
21.pl == 2PL.INCL
21pl.IMP == 2PL.INCL
2>1.IMP == IMP.2>1
2>3 == 2>3
2pl == 2PL.EXCL
2s == 2SG
2s.IMP == IMP.2SG
3 == 3
3.pl == 3PL
3.s == 3SG
3/0 == 3/0
3>1.IMP == IMP.3>1
3>2 == 3>2
3>4 == 3>4
3pl == 3PL
3s == 3SG
? == ???
?Eng == ???
causative == CAUS
comp == COMP
dem+G.pxl == DEM.PROX
dim == DIM
direct == DIR
Eng == ???
English == ???
fina; == STEM
final == STEM
final.0 == STEM.0
final.1/2 == STEM.1/2
final.3 == STEM.3
function == STEM
FUT == FUT
fut == FUT
Future == FUT
future == FUT
future.3 == FUT.3
inan.pl == INAN.PL
inchoative == INCH
incl == INCL
initial == STEM
Intj == INTJ
inverse == INV
loc == LOC
medial == STEM
ni == 1
not == NEG
Obv == OBV
obv == OBV
p == DEM
p.aff == AFF
p.dem == DEM
p.emph == EMPH
p.focus == FOC
p.hesitat == uh
p.hesitate == uh
p.intj == INTJ
p.neg == NEG
p.polar == Q
p.quest == Q
past == PST
pl == PL
poss == POSS
preverb == PVB
pvb.conj == PVB.CONJ
TA.theme.sign == TR.ANIM
theme.sign == TR.ANIM
TI.theme == TR.INAN
TI.theme.sign == TR.INAN
vti.final == STEM.TR.INAN
Ø == 3SG>0
Ø.IMP == IMP
# stuff added by Robert on 2016-01-21
??? == ???
this == PROX
vai.fin == STEM.INTR.ANIM
that == DIST
p,quest == Q
2.sg == 2SG
3.sg == 3SG
be == COP
vii.fin == STEM.INTR.INAN
p,intj == INTJ
2.sg>0 == 2SG>0
p,wh == WH
passive.1/2 == PASS.1/2
passive.3 == PASS.3
1.sg == 1SG
pvb,conj == PVB.CONJ
thm(vti.non3) == TR.INAN.1/2
emph == EMPH
vta.fin == STEM.TR.ANIM
thm(vta) == TR.ANIM
inan.obv == INAN.OBV
an.pl == ANIM.PL
caus == CAUS
vti.fin == STEM.TR.INAN
vai+o.fin == STEM.INTR.ANIM
fut.1/2 == FUT.1/2
3.sg>4 == 3SG>4
2.sg>3.sg == 2SG>3SG
1.sg>3.sg == 1SG>3SG
0.pl == 0PL
1.sg>0 == 1SG>0
2.sg>1.sg == 2SG>1SG
4 == 4
thm(vti) == TR.INAN
don't == IMP.NEG
fut.3 == FUT.3
vta.fin.passive.1/2 == STEM.PASS.TR.ANIM.1/2
an.obv == ANIM.OBV
thm(vta.non3) == TR.ANIM.1/2
0.obv.sg == 0SG.OBV
2.pl == 2PL.EXCL
pvb,rel == PVB.REL
thm.inv(vta) == TR.ANIM.INV
vti.passive == STEM.PASS.TR.ANIM
1.pl == 1PL
inan.obv.pl == INAN.PL.OBV
1.sg>2.sg == 1SG>2SG
3.sg>0 == 3SG>0
3.sg>21.pl == 3SG>1NSG.INCL
2.sg>3.pl == 2SG>3PL
3.pl>0 == 3PL>0
3.pl>2.sg == 3PL>2SG
3.pl>4 == 3PL>4
3.sg>1.sg == 3SG>1SG
appl.passive.1/2 == APPL.PASS.1/2
impers == IMPERS
intrans == INTR
thm(vta.inv.non3) == TR.ANIM.INV.1/2
vai+o == STEM.INTR.ANIM
X == IMPERS
X>3.pl == IMPERS>3PL
yyy == ???

[morphology_tiers]
mortyp == pos_raw
mormea == gloss_raw
actmor == morphemes
tarmor == morphemes

[correspondences]
actual == phonetic
model == phonetic_target
p == default
. == default
q == question
? == question
e == exclamation
! == exclamation
trail off == trail off
trail off question == trail off question
interruption == interruption
self interruption == self interruption
self interruption question == self interruption question
quotation precedes == quotation precedes
quotation next line == quotation next line
interruption question == interruption question
# might use this kind of mapping for XML parsing
# <u who="">
# <media start="" end="">
# <actual>
# <model>
# <ss>, <ph>
# <a type="english translation">
# <a type="comments">
# <t>
# <w>
# <a type="extension" flavor="mortyp">
# <a type="extension" flavor="tarmor">
# <a type="extension" flavor="mormea">
# <a type="extension" flavor="actmor">

[regex]
'\+' == '.'
',' ==  '.'
